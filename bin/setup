#!/usr/bin/env bash

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly HOMEBREW_DIR="chezmoi/dot_application-config/homebrew"
readonly FORMULA_FILE="${HOMEBREW_DIR}/brew-formula.txt"
readonly CASKS_FILE="${HOMEBREW_DIR}/brew-casks.txt"
readonly MAS_FILE="${HOMEBREW_DIR}/mas-list.txt"
readonly MANUAL_APPS_FILE="chezmoi/dot_application-config/manual_apps.yml"

# Color codes
readonly GREEN='\033[0;32m'
readonly RED='\033[0;31m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m'

# =============================================================================
# Utility Functions
# =============================================================================

log_info() {
    echo -e "${GREEN}${1}${NC}"
}

log_warning() {
    echo -e "${YELLOW}${1}${NC}"
}

log_error() {
    echo -e "${RED}${1}${NC}"
}

spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep -F "$pid")" ]; do
        local temp=${spinstr#?}
        printf " [%c] " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

is_empty_or_comment() {
    local line="$1"
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]
}

install_with_spinner() {
    local name="$1"
    shift
    local install_cmd=("$@")

    echo -n "Installing $name..."
    "${install_cmd[@]}" > /dev/null 2>&1 &
    local pid=$!
    spinner "$pid"
    wait "$pid"

    if [[ $? -eq 0 ]]; then
        echo -e " ${GREEN}✅${NC}"
        return 0
    else
        echo -e " ${RED}❌${NC}"
        return 1
    fi
}

# =============================================================================
# Package Management Functions
# =============================================================================

check_and_install_homebrew() {
    if ! command -v brew &> /dev/null; then
        log_warning "Homebrew not found. Installing Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    else
        log_info "Homebrew is already installed."
    fi
}

check_and_install_mas() {
    if ! command -v mas &> /dev/null; then
        log_warning "mas not found. Installing mas..."
        brew install mas
    fi
}

# Get all installed packages in one call (optimization)
get_all_installed_formulas() {
    brew list 2>/dev/null || true
}

get_all_installed_casks() {
    brew list --cask 2>/dev/null || true
}

get_all_installed_mas() {
    mas list 2>/dev/null || true
}

process_package_file() {
    local file_path="$1"
    local package_type="$2"
    local installed_list="$3"
    shift 3
    local install_cmd=("$@")

    if [[ ! -f "$file_path" ]]; then
        if [[ "$package_type" == "formula" ]]; then
            log_error "Error: $file_path not found!"
            exit 1
        else
            log_warning "${package_type^} file not found at $file_path, skipping ${package_type} installation."
            return 0
        fi
    fi

    echo "Checking ${package_type}s..."

    local missing_items=()
    local all_items=()

    while IFS= read -r line || [[ -n "$line" ]]; do
        is_empty_or_comment "$line" && continue

        local item_id item_name

        if [[ "$package_type" == "mas" ]]; then
            item_id=$(echo "$line" | awk '{print $1}')
            item_name=$(echo "$line" | awk '{$1=""; print $0}' | sed 's/^ *//')
        else
            item_id="$line"
            item_name="$line"
        fi

        all_items+=("$item_id")

        # Check if item is in the installed list
        if [[ "$package_type" == "mas" ]]; then
            # For mas apps, check by ID prefix
            if echo "$installed_list" | grep -qF "$item_id"; then
                printf "${GREEN}✅ ${NC}%s\n" "$item_name"
            else
                printf "${RED}◼️  ${NC}%s\n" "$item_name"
                missing_items+=("$item_id")
            fi
        else
            # For formulas and casks, check exact match
            if echo "$installed_list" | grep -qFx "$item_id"; then
                printf "${GREEN}✅ ${NC}%s\n" "$item_name"
            else
                printf "${RED}◼️  ${NC}%s\n" "$item_name"
                missing_items+=("$item_id")
            fi
        fi
    done < "$file_path"

    echo

    if [[ ${#missing_items[@]} -eq 0 ]]; then
        log_info "All ${package_type}s are already installed."
        return 0
    fi

    log_warning "Installing ${package_type}s: ${missing_items[*]}"

    for item_id in "${missing_items[@]}"; do
        local item_name

        if [[ "$package_type" == "mas" ]]; then
            item_name=$(grep "^$item_id" "$file_path" | awk '{$1=""; print $0}' | sed 's/^ *//')
        else
            item_name="$item_id"
        fi

        install_with_spinner "$item_name" "${install_cmd[@]}" "$item_id"
    done
}

install_formulas() {
    local installed_formulas=$(get_all_installed_formulas)
    process_package_file "$FORMULA_FILE" "formula" "$installed_formulas" \
        brew install
}

install_casks() {
    local installed_casks=$(get_all_installed_casks)
    process_package_file "$CASKS_FILE" "cask" "$installed_casks" \
        brew install --cask
}

install_mas_apps() {
    check_and_install_mas
    local installed_mas=$(get_all_installed_mas)
    process_package_file "$MAS_FILE" "mas" "$installed_mas" \
        mas install
}

open_manual_apps() {
    if [[ ! -f "$MANUAL_APPS_FILE" ]]; then
        log_warning "Manual apps file not found at $MANUAL_APPS_FILE, skipping."
        return 0
    fi

    # Check if AUTO mode is enabled
    if [[ "${AUTO:-false}" != "true" ]]; then
        log_info "Manual apps detected. Set AUTO=true to open download URLs in browser."
        return 0
    fi

    echo "Processing manual apps..."

    local urls=()
    local in_url=false

    # Parse YAML file to extract URLs
    while IFS= read -r line; do
        # Skip comments and empty lines
        if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
            continue
        fi

        # Check if this is a URL line
        if [[ "$line" =~ ^[[:space:]]*url:[[:space:]]*\"(.+)\"[[:space:]]* ]]; then
            local url="${BASH_REMATCH[1]}"
            # Only add non-empty URLs
            if [[ -n "$url" ]]; then
                urls+=("$url")
            fi
        fi
    done < "$MANUAL_APPS_FILE"

    if [[ ${#urls[@]} -eq 0 ]]; then
        log_warning "No download URLs found in manual apps file."
        log_info "Please fill in the 'url' fields in $MANUAL_APPS_FILE"
        return 0
    fi

    log_info "Opening ${#urls[@]} download URL(s) in browser..."

    # Open each URL in a new browser tab
    for url in "${urls[@]}"; do
        # Validate URL scheme - only allow http:// and https://
        if [[ "$url" =~ ^https?:// ]]; then
            log_info "Opening: $url"
            open "$url"
            # Small delay to ensure tabs open in order
            sleep 0.5
        else
            log_warning "Skipping invalid or potentially dangerous URL: $url"
            log_warning "Only http:// and https:// URLs are allowed"
        fi
    done

    echo
    log_info "Manual app downloads opened in browser."
    log_warning "Please install these apps manually and run the backup script again to update versions."
}

# =============================================================================
# Main Installation Flow
# =============================================================================

main() {
    echo "Installing Xcode Command Line Tools"
    xcode-select --install || true

    check_and_install_homebrew
    install_formulas
    install_casks
    install_mas_apps
    open_manual_apps

    log_info "Setup completed."
}

# =============================================================================
# Script Execution
# =============================================================================

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
