#!/usr/bin/env fish

# Configuration
set font_names \
    "LINESeed" \
    "Chonburi" \
    "CooperBlack" \
    "LEMONMILK" \
    "Notedry" \
    "'High Empathy'" \
    "'Playful Boxes'" \
    "'Super Kindly'"

# Helper Functions
function clean_font_pattern
    set pattern $argv[1]
    set pattern (string replace -a "'" "" $pattern)
    echo $pattern
end

function font_matches_pattern
    set font_basename $argv[1]
    set clean_pattern $argv[2]
    string match -q "*$clean_pattern*" $font_basename
end

function is_font_managed_by_chezmoi
    set font_file $argv[1]
    set chezmoi_source_path (chezmoi source-path $font_file 2>/dev/null)
    test -f "$chezmoi_source_path"
end

function find_matching_pattern
    set font_basename $argv[1]
    
    for font_pattern in $font_names
        set clean_pattern (clean_font_pattern $font_pattern)
        if font_matches_pattern $font_basename $clean_pattern
            echo $clean_pattern
            return 0
        end
    end
    return 1
end

function display_font_group
    set font_list $argv[1..-3]
    set group_title $argv[-2]
    set color_code $argv[-1]
    
    if test (count $font_list) -gt 0
        echo $group_title
        
        # Group fonts by pattern
        for font_pattern in $font_names
            set clean_pattern (clean_font_pattern $font_pattern)
            set pattern_fonts
            
            # Find fonts that match this pattern
            for font in $font_list
                if font_matches_pattern $font $clean_pattern
                    set pattern_fonts $pattern_fonts $font
                end
            end
            
            # Print pattern group if fonts found
            if test (count $pattern_fonts) -gt 0
                # Brown bold for wildcard pattern
                echo -e "\033[1;33m$clean_pattern*\033[0m"
                # Color for font basenames
                echo -e "$color_code"(string join ", " $pattern_fonts)"\033[0m"
                echo
            end
        end
    end
end

function backup_configs
    echo "Backing up Ghostty, mise & starship configs"
    chezmoi add ~/.config/ghostty/
    chezmoi add ~/.config/mise/
    chezmoi add ~/.config/starship.toml
end

function backup_applications_config
    echo "Backing up application configs"
    chezmoi add ~/.application-config/
end

function backup_homebrew
    echo "Backing up Homebrew (formula, casks, mas)"
    set homebrew_dir ~/.local/share/chezmoi/chezmoi/dot_application-config/homebrew

    brew leaves > "$homebrew_dir/brew-formula.txt"
    brew list --cask > "$homebrew_dir/brew-casks.txt"
    mas list > "$homebrew_dir/mas-list.txt"
end

function normalize_app_name
    set name $argv[1]
    # Convert to lowercase, remove spaces and hyphens, remove common suffixes
    echo $name | string lower | string replace -a ' ' '' | string replace -a '-' '' | string replace -r '(app|desktop)$' ''
end

function get_existing_app_data
    set app_name $argv[1]
    set manual_apps_file $argv[2]

    if test -f "$manual_apps_file"
        # Extract URL and notes for this app from existing file
        set in_app false
        set url ""
        set notes ""

        for line in (cat "$manual_apps_file")
            if string match -q "*name: \"$app_name\"*" $line
                set in_app true
            else if test $in_app = true
                if string match -q "*url:*" $line
                    set url (string replace -r '.*url: *"([^"]*)".*' '$1' $line)
                else if string match -q "*notes:*" $line
                    set notes (string replace -r '.*notes: *"([^"]*)".*' '$1' $line)
                    echo "$url|$notes"
                    return 0
                else if string match -q "  - name:" $line
                    # Started new app entry
                    break
                end
            end
        end
    end

    echo "|"
    return 1
end

function backup_manual_apps
    echo "Detecting manually installed apps..."

    set manual_apps_file ~/.local/share/chezmoi/chezmoi/dot_application-config/manual_apps.yml
    set temp_file (mktemp)

    # Verify temp file was created successfully
    if test -z "$temp_file"
        echo "Error: Failed to create temporary file"
        return 1
    end

    # Set restrictive permissions on temp file
    chmod 600 "$temp_file"

    # Apps to ignore (bundled with other apps or system apps)
    set ignore_apps \
        "Google Docs" \
        "Google Sheets" \
        "Google Slides" \
        "logioptionsplus"

    # Get lists of managed apps
    set cask_apps (brew list --cask 2>/dev/null)
    set mas_apps (mas list 2>/dev/null | awk '{$1=""; print $0}' | sed 's/^ *//' | sed 's/ *(.*//' | sed 's/\.app$//')

    # Start YAML file
    echo "# Manual Applications (not installed via Homebrew or Mac App Store)" > $temp_file
    echo "# Fill in the 'url' field for each app to enable automated opening in browser" >> $temp_file
    echo "" >> $temp_file
    echo "apps:" >> $temp_file

    set manual_count 0

    # Check each app in /Applications
    for app_path in /Applications/*.app
        if not test -d $app_path
            continue
        end

        set app_name (basename $app_path .app)
        set normalized_app (normalize_app_name $app_name)
        set is_manual true

        # Check if app is in ignore list
        for ignore_app in $ignore_apps
            if test "$app_name" = "$ignore_app"
                set is_manual false
                break
            end
        end

        # Check if installed by Homebrew cask
        if test $is_manual = true
            for cask in $cask_apps
                set normalized_cask (normalize_app_name $cask)
                # Check both directions: if cask contains app or app contains cask
                if string match -q "*$normalized_cask*" $normalized_app; or string match -q "*$normalized_app*" $normalized_cask
                    set is_manual false
                    break
                end
            end
        end

        # Check if installed by mas
        if test $is_manual = true
            for mas_app in $mas_apps
                set normalized_mas (normalize_app_name $mas_app)
                if string match -q "*$normalized_mas*" $normalized_app; or string match -q "*$normalized_app*" $normalized_mas
                    set is_manual false
                    break
                end
            end
        end

        # If manual, add to YAML
        if test $is_manual = true
            set manual_count (math $manual_count + 1)

            # Get existing URL and notes if available
            set existing_data (get_existing_app_data "$app_name" "$manual_apps_file")
            set url (string split "|" $existing_data)[1]
            set notes (string split "|" $existing_data)[2]

            echo "  - name: \"$app_name\"" >> "$temp_file"
            echo "    url: \"$url\"  # Fill in download URL" >> "$temp_file"
            echo "    notes: \"$notes\"" >> "$temp_file"
            echo "" >> "$temp_file"
        end
    end

    # Move temp file to final location (atomic operation)
    mv -f "$temp_file" "$manual_apps_file"

    echo "Found $manual_count manually installed apps"
    echo "Saved to: $manual_apps_file"
    echo
end

function process_fonts
    echo "Backing up fonts..."
    echo
    
    set managed_fonts
    set added_fonts
    
    # Process each font file
    for font_file in ~/Library/Fonts/*
        if not test -f "$font_file"
            continue
        end

        set font_basename (basename "$font_file")
        set matching_pattern (find_matching_pattern "$font_basename")

        if test $status -eq 0
            if is_font_managed_by_chezmoi "$font_file"
                set managed_fonts $managed_fonts $font_basename
            else
                chezmoi add "$font_file"
                set added_fonts $added_fonts $font_basename
            end
        end
    end
    
    # Display results with original colors
    display_font_group $managed_fonts "Fonts already managed by chezmoi:" "\033[34m"
    display_font_group $added_fonts "Added fonts:" "\033[32m"
    
    check_missing_patterns
end

function check_missing_patterns
    for font_pattern in $font_names
        set clean_pattern (clean_font_pattern "$font_pattern")
        set found false

        for font_file in ~/Library/Fonts/*
            if test -f "$font_file"
                set font_basename (basename "$font_file")
                if font_matches_pattern "$font_basename" "$clean_pattern"
                    set found true
                    break
                end
            end
        end

        if test $found = false
            echo -e "No fonts found matching pattern: \033[31m$font_pattern\033[0m"
        end
    end
end

# Main execution
function main
    echo "Starting backup process..."

    backup_configs
    backup_applications_config
    backup_homebrew
    backup_manual_apps
    process_fonts

    echo "Backup completed!"
end

# Run main function
main
